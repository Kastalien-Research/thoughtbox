export const INVERSION_CONTENT = `# Inversion

Instead of seeking success, identify and avoid paths to failure.

## When to Use
- Direct path to goal is unclear
- Want to avoid common failures
- Complex systems with many failure modes
- Decision with asymmetric risk (downside >> upside)

## Process

### Step 1: State the Goal
What are you trying to achieve?
- "Build a successful product"

### Step 2: Invert: Ask How to Fail
Instead of "how do I succeed?", ask "how would I guarantee failure?"
- "How would I ensure this product fails completely?"

### Step 3: Generate Failure Modes
List all the ways to fail:
- Ignore user feedback
- Never ship anything
- Build what competitors build
- Hire only similar people
- Avoid all risk
- Change direction every week

### Step 4: Invert Again: Avoid These
Convert each failure mode to an avoidance rule:
- Ignore feedback → Establish regular user research
- Never ship → Set shipping cadence
- Copy competitors → Find unique positioning
- Similar hires → Diverse hiring criteria
- Avoid risk → Calculated risk-taking framework
- Change constantly → Clear strategy with review cycles

### Step 5: Check Coverage
Does avoiding all these failures get you to success? Usually yes—success is often the absence of failure modes.

## Key Principle
It's often easier to identify what definitely doesn't work than what definitely does. Avoiding stupidity beats seeking brilliance.

## Example Application

**Goal:** "Successful software project"

**How to guarantee failure:**
1. No clear requirements → scope creep forever
2. No testing → bugs compound
3. No version control → chaos, lost work
4. No communication → misalignment
5. No documentation → knowledge loss
6. Premature optimization → wasted effort
7. No deployment process → fear of shipping
8. Ignoring technical debt → velocity death spiral

**Inverted to success rules:**
1. Document requirements and change process
2. Test critical paths
3. Use version control religiously
4. Over-communicate status and blockers
5. Document decisions and architecture
6. Optimize only when data shows need
7. Automate deployment early
8. Budget time for debt reduction

**Application:** Use as a project health checklist.

## Classic Inversions

**"How to build a great team" →**
"How to destroy a team":
- Hire yes-men
- Punish mistakes publicly
- Hoard information
- Take credit, assign blame
- Change priorities constantly

**"How to write clean code" →**
"How to write unmaintainable code":
- No tests
- Clever one-liners
- Misleading names
- Deep nesting
- Global state

**"How to have a good meeting" →**
"How to waste everyone's time":
- No agenda
- No decision-maker
- Wrong people
- No time limit
- No follow-up

## Inversion in Different Domains

**Security:** "How would I break this?" → Then prevent that

**Reliability:** "How would this fail?" → Then add safeguards

**UX:** "How would I frustrate users?" → Then avoid that

**Career:** "How would I stagnate?" → Then do opposite

## When Inversion Works Best

- **Asymmetric outcomes:** Avoiding disaster matters more than optimizing success
- **Complex systems:** Many ways to fail, fewer ways to succeed
- **Low visibility:** Hard to see what success looks like
- **Prevention:** Easier to prevent problems than create positive outcomes

## Anti-patterns
- Only using inversion (also need positive vision)
- Listing trivial failures ("don't delete the codebase")
- Not converting failures to actionable avoidances
- Analysis paralysis from too many failure modes
`;
